\documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo practico 1}
\subtitulo{Especificacion y WP}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos}
\grupo{X-force}

\integrante{Krivonosoff, Thiago}{310/24}{thiagokribas@gmail.com}
\integrante{Pellitero, Agustin}{185/24}{agustinignaciopelli@gmail.com}
\integrante{Miguel, Facundo}{702/24}{facumiguel4025@gmail.com}
\integrante{Montenegro, Ulises}{477/24}{ulinicolasmonte@gmail.com}
% Pongan cuantos integrantes quieran

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

% \section{Ejemplo de sección}
% \subsection{Subsección: ambientes comunes de \LaTeX}

% Lo principal: las fórmulas. Se puede poner en una linea, como $x_i = x_{i-1} + x_{i-2}$, o ponerse más grande:

% \begin{equation}
% 	\sum\limits_{i=0}^{n} i
% 	\label{eq:1}
% \end{equation}

% Y se pueden citar ecuaciones con \verb|\eqref{nombreDeEq}|: \eqref{eq:1}

% Ejemplo de itemizado:

% \begin{itemize}
% 	\item Item 1
% 	\item Item 2
% 	\item Item 3
% \end{itemize}

% Ejemplo de enumerado con menor distancia entre items:

% \begin{enumerate} \setlength\itemsep{0cm}
% 	\item Item 1
% 	\item Item 2
% 	\item Item 3
% \end{enumerate}

% Podemos escribir mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto.

% Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo.

% \vspace{0.3cm}

% Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos.

% \vspace{0.3cm}

% La tabla \ref{tab:ejemplo} es un ejemplo de cómo se hace una tabla.

% \begin{table}[h!]
% 	\centering
% 	\begin{tabular}{||l c c r||} 
% 		\hline
% 		Col1 & Col2 & Col2 & Col3 \\ [0.5ex] 
% 		\hline\hline
% 		1 & 6 & 87837 & 787 \\ 
% 		2 & 7 & 78 & 5415 \\
% 		3 & 545 & 778 & 7507 \\
% 		4 & 545 & 18744 & 7560 \\
% 		5 & 88 & 788 & 6344 \\
% 		\hline
% 	\end{tabular}
% 	\caption{Ejemplo de tabla}
% 	\label{tab:ejemplo}
% \end{table}


% La figura \ref{fig:subfigs} es un ejemplo de cómo se agrega una imagen.

% \begin{figure}[ht]
% 	\centering
% 	\includegraphics[width=0.6\textwidth]{logo_dc.jpg}
% 	\caption{Ejemplo de figura}
% 	\label{fig:ejemplo}
% \end{figure}

% \begin{figure}[ht!]
% 	\begin{subfigure}{0.5\textwidth}
% 		\includegraphics[width=0.9\linewidth]{LaTeX-project} 
% 		\caption{Logo de LaTeX}
% 		\label{fig:subfig1}
% 	\end{subfigure}
% 	\begin{subfigure}{0.5\textwidth}
% 		\includegraphics[width=0.7\linewidth]{TeX}
% 		\caption{Logo de TeX}
% 		\label{fig:subfig2}
% 	\end{subfigure}
% 	\caption{Ejemplo para poner dos figuras juntas. Y citarlas por separado a (\subref{fig:subfig1}) y (\subref{fig:subfig2}).}
% 	% OJO: el caption siempre va antes del label
% 	\label{fig:subfigs}
% \end{figure}



% % Para hacer que quede todo en una misma linea, se puede usar minipage
% %\begin{minipage}[t]{\textwidth}
% 	\begin{lstlisting}[caption={Ejemplo de código (usando los estilos de la cátedra, ver las macros para más detalles)},label=code:for]
% res := 0;
% i := 0;
% while (i < s.size()) do
% 	res := res + s[i];
% 	i := i + 1
% endwhile
% 	\end{lstlisting}
% %\end{minipage}

% Si se pone un label al \verb|lstlisting|, se puede referenciar: Código \ref{code:for}.


% \subsection{Macros de la cátedra para especificar}

% \begin{proc}{nombre}{\In paramIn : \nat, \Inout paramInout : \TLista{\ent}}{tipoRes}
% 	%    \modifica{parametro1, parametro2,..}
% 	\requiere{expresionBooleana1}
% 	\asegura{expresionBooleana2}
% 	\aux{auxiliar1}{parametros}{tipoRes}{expresion}
% 	\pred{pred1}{parametros}{expresion} 
% \end{proc}

% \aux{auxiliarSuelto}{parametros}{tipoRes}{expresion}
% % \paraTodo{variable}{tipo}{expresion}
% % \existe{variable}{tipo}{expresion}
% % Pueden tener [unalinea] para que no se divida en varias lineas
% \pred{predSuelto}{parametros}{\paraTodo[unalinea]{variable}{tipo}{algo \implicaLuego expresion}}
% \pred{predSuelto}{parametros}{\existe[unalinea]{variable}{tipo}{algo \yLuego expresion}}


% A partir de aca empieza el TP.

% %salto de lineas

\section{Punto 1}
\subsection{Ejercicio 1}

\begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{noRepetidos(ciudades) \land noHabitantesNegativos(ciudades)}
	\asegura{ \longitud{res} \leq \longitud{ciudades} }
	\asegura{ \paraTodo[unalinea]{elem}{Ciudad}{(elem.habitantes > 50000 \land elem \in ciudades) \leftrightarrow elem \in res}}
\end{proc}

\pred{noRepetidos}{\In ciudades: \TLista{Ciudad}}
	{\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |ciudades|} \implicaLuego (i \neq j \implica ciudades[i].nombre \neq ciudades[j].nombre)}

\pred{noHabitantesNegativos}{\In ciudades: \TLista{Ciudad}}
	{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades|} \implicaLuego ciudades[i].habitantes >= 0}

\subsection{Ejercicio 2}

\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades: \TLista{Ciudad}, \In mayoresDeCiudades: \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{noRepetidos(menoresDeCiudades) \land noRepetidos(mayoresDeCiudades)}
	\requiere{noHabitantesNegativos(menoresDeCiudades) \land noHabitantesNegativos(mayoresDeCiudades)} 
	\requiere{|menoresDeCiudades| = |mayoresDeCiudades| \yLuego \\ mismosElementos(menoresDeCiudades, mayoresDeCiudades)}
	\asegura{|res| = |mayoresDeCiudades|}
	\asegura{\paraTodo[unalinea]{elem}{Ciudad}{(elem \in res) \leftrightarrow  \\ 
	{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |res|}\implicaLuego \existe[unalinea]{j}{\ent}{0 \leq j < |res|}}}
		\yLuego \\
		{mayoresDeCiudades[i].nombre = menoresDeCiudades[j].nombre} \implica \\
		(res[i].nombre = mayoresDeCiudades[i].nombre \land \\
		res[i].habitantes = mayoresDeCiudades[i].habitantes + menoresDeCiudades[j].habitantes)}
\end{proc}

\pred{mismosElementos}{\In s1: \TLista{Ciudad}, \In s2: \TLista{Ciudad}}{
	\\{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |s1|} \implicaLuego \existe[unalinea]{j}{\ent}{0 \leq j < |s1|} \yLuego s1[i].nombre = s2[j].nombre}
}

\subsection{Ejercicio 3}

\begin{proc}{hayCamino}{\In distancia: \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{\bool}
	\requiere{esCuadrada(distancia) \yLuego filaIgualColumna(distancia)}
	\requiere{0 \leq desde < |distancia|}
	\requiere{0 \leq hasta < |distancia|}
	\requiere{matrizTodosPositivos(distancia)}
	\asegura{res = True \leftrightarrow \existe[unalinea]{sec}{\TLista{\ent}}{|sec| > 1} \yLuego secuenciaEsCamino(distancia, sec, desde, hasta)}

\end{proc}

\pred{secuenciaEsCamino}{\In distancia: \TLista{\TLista{\ent}}, \In sec: \TLista{\ent}, \In desde: \ent, \In hasta: \ent}{
	sec[0] = desde \land sec[|sec|-1] = hasta \land \paraTodo[unalinea]{i}{\ent}{0 \leq i < |sec|} \implicaLuego \\ 	
	0 \leq sec[i] < |distancia| \yLuego todosConexionAnterior(sec, distancia)}


\pred{todosConexionAnterior}{\In sec: \TLista{\ent}, \In mat: \TLista{\TLista{\ent}}}{
	\paraTodo[unalinea]{i}{\ent}{1 \leq i < |sec| \implicaLuego mat[sec[i]][sec[i-1]] \neq 0
}}
\pred{esCuadrada}{\In mat: \TLista{\TLista{\ent}}}{
	\paraTodo[unalinea]{i}{\ent}{0 \leq i < |mat|} \implicaLuego |mat| = |mat[i]|
}\\
\pred{filaIgualColumna}{\In mat: \TLista{\TLista{\ent}}}{
	\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |mat|} \implicaLuego mat[i][j] = mat[j][i]
}\\
\pred{matrizTodosPositivos}{\In mat: \TLista{\TLista{\ent}}}{
	\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |mat|} \implicaLuego 0 \leq mat[i][j] 
}\\
\subsection{Ejercicio 4}

\begin{proc}{cantidadCaminosNSaltos}{\Inout conexion: \TLista{\TLista{\ent}}, \In n: \ent}{}
	\requiere{1 \leq n}
    \requiere{esCuadrada(conexion) \yLuego filaIgualColumna(conexion)}
	\requiere{\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |conexion|} \implicaLuego conexion[i][j] \in [0,1]}
	\requiere{conexion = C_0}
	\asegura{\existe[unalinea]{sec}{\TLista{\TLista{\TLista{\ent}}}}{|sec| = n} \land sec[0] = C_0 \land conexion = sec[|sec| - 1] \leftrightarrow \\
	\paraTodo[unalinea]{i}{\ent}{1 \leq i < |sec|} \implicaLuego esCuadrada(sec[i]) \land |sec[i]| = |conexion| \implicaLuego \\
	esLaMultiplicacion(sec[i], C_0, sec[i-1])  }
\end{proc}

\pred{esLaMultiplicacion}{\In mat: \TLista{\TLista{\ent}}, \In mat_0: \TLista{\TLista{\ent}}, \In mat_1: \TLista{\TLista{\ent}}}{
	\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |mat|} \implicaLuego mat[i][j] =  \sum_{k = 0}^{|mat| - 1} mat_0[i][k] * mat_1[k][j]
}

% \aux{inversa}{\In mat: \TLista{\TLista{\ent}}}{\TLista{\TLista{\ent}}}{\\
% \paraTodo[unalinea]{i}{\ent}{0 \leq i < |mat|}\implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |mat|} \implicaLuegos res[j][i] = mat[i][j]
% }

% \aux{multiplicarMatrices}{\In mat1: {\TLista{\TLista{\ent}}}, \In mat2: {\TLista{\TLista{\ent}}}}{\TLista{\TLista{\ent}}}{\\
% 	\paraTodo[unalinea]{i}{\ent}{0 \leq i < |mat1|}\implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |mat1[i]|} \implicaLuego \\
% 	res[i][j] = productoEscalar(mat1[i], inversa(mat2)[j])
% }

% \aux{productoEscalar}{\in fila: \TLista{\ent}, \in col: \TLista{\ent}}{\ent}{\\
% 	\paraTodo[unalinea]{i}{\ent}{0 \leq i < |fila|} \implicaLuego \paraTodo[unalinea]{j}{\ent}{0 \leq j < |col|} \implicaLuego res = \sum_{i = 0}^{|fila| - 1} fila[i] * fila[j]
% }

\subsection {Ejercicio 5}

\begin{proc}{caminoMinimo}{\In origen: \ent, \In destino: \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}
	\requiere{esCuadrada(distancias) \yLuego filaIgualColumna(distancias)}
	\requiere{0 \leq destino, origen < |distancias|}
	\requiere{matrizTodosPositivos(distancias)}

	\asegura{\existe[unalinea]{s_1}{\TLista{\ent}}{|s_1| > 1} \land res = s_1 \leftrightarrow \paraTodo[unalinea]{s_2}{\TLista{\ent}}{|s_2| > 1} \implicaLuego \\
	(secuenciaEsCamino(distancias, s_1, origen, destino) \land secuenciaEsCamino(distancias, s_2, origen, destino) \land \\
	(longitudCamino(s_1, distancias) \leq longitudCamino(s_2, distancias)) }
	\asegura{res = [] \leftrightarrow \paraTodo[unalinea]{s}{\TLista{\ent}}{\text{¬} secuenciaEsCamino(distancias, s, origen, destino)} }

\end{proc}

\aux{longitudCamino}{\In sec: \TLista{\ent}, \In distancias: \TLista{\TLista{\ent}}}{\ent}{
	\sum_{i = 1}^{|sec|-1} distancias[sec[i]][sec[i-1]]
}

\section{Punto 2}
\subsection{Ejercicio 1}
\subtitle{Demostramos que la implementación es correcta con respecto a la especificación dada mediante teorema de invariante y teorema de terminación.}

Por teorema del invariante primero debemos demostrar los siguientes puntos:

\begin{itemize}
    \item \( P_c \implica I \)
    \item \( \{I \land B\} \ S \ \{I\} \)
    \item \( (I \land \neg B) \implica Q_c \)
\end{itemize}

Elegimos nuestra invariante.

I \equiv 0 \leq i \leq |\text{ciudades}| \land \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res

\textbf{Primer paso} Probamos primero la implicación de la precondición del ciclo hacia el invariante:

P_c \implica I

\[
res = 0 \land i = 0 \implica 0 \leq i \leq |\text{ciudades}| \land \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res
\]

\[
 0 \leq 0 \leq |\text{ciudades}| \land \sum_{j=0}^{0-1} \text{ciudades}[j].habitantes = 0
\]

\[
True \land True
\]

\[
True
\]

\newpage

\textbf{Segundo paso} Ahora probamos que vale la siguiente tripla de Hoare:

\{I \land B\} \ S \ \{I\}

Para probar que esto sea verdadero se debe cumplir \{I \land B\} \implica wp(S, I)   

Hacemos uso del axioma para calcular wp(S, I).
\[
wp(S, I) \equiv wp(S_1, wp(S_2, I))
\]

\[
wp(S_2, I) \equiv def(S_2) \yLuego I_{i := i+1}^{i}
\]

\[
wp(S_2, I) \equiv True \land 0 \leq i+1 \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes = res
\]

Terminamos de definir el wp de S2:

\[
wp(S_2, I) \equiv 0 \leq i+1 \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes = res
\]

Ahora definimos el wp de S1:

\[
wp(S_1, wp(S_2, I)) \equiv wp(res := res + \text{ciudades}[i].habitantes, 0 \leq i+1 \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes = res)
\]

\[
wp(S_1, wp(S_2, I)) \equiv def(res := res + \text{ciudades}[i].habitantes) \yLuego I_{res := res + \text{ciudades}[i].habitantes}^{res}
\]

\[
wp(S_1, wp(S_2, I)) \equiv 0 \leq i < |\text{ciudades}| \yLuego 0 \leq i+1 \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes = res + \text{ciudades}[i].habitantes
\]

\[
wp(S_1, wp(S_2, I)) \equiv 0 \leq i < |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes = res + \text{ciudades}[i].habitantes
\]

\[
wp(S_1, wp(S_2, I)) \equiv 0 \leq i < |\text{ciudades}| \yLuego \sum_{j=0}^{i} \text{ciudades}[j].habitantes - \text{ciudades}[i].habitantes = res 
\]

Ahora queda definido el wp de S:

\[
wp(S, I) \equiv 0 \leq i < |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res
\]

Ahora veo la implicacion del invariante y la guarda hacia wp(S,I):

\[
\{I \land B\} \implica wp(S, I) \equiv
\]

\[
 0 \leq i < |\text{ciudades}| \land 0 \leq i \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res \implica 
\]

\[
0 \leq i < |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res
\]

Se cancelan los terminos y queda:

\[
0 \leq i \leq |\text{ciudades}| \implica True
\]

\[
True
\]

\textbf{Tercer paso} Ahora probamos que vale la siguiente implicación:
( I \land \neg B \implica Q_c )

\[
0 \leq i \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res \land i \geq |\text{ciudades}| \implica
\]

\[
 \sum_{j=0}^{|\text{ciudades}|-1} \text{ciudades}[j].habitantes = res \land i = |\text{ciudades}|
\]

i esta entre las longitudes de ciudades y se cancelan las sumatorias

\[
True
\]

Ahora por teorema de terminación debemos demostrar que la ejecucion del ciclo siempre termina, nuestra función variante:

\textbf{F_v = |\text{ciudades}| - i - 1}

Para probar que esto sea verdadero se debe cumplir lo siguiente.

\begin{itemize}
    \item \( \{ I \land B \land F_v = v_0\} S \{ F_v < v_0 \} \)
    \item \( (I \land F_v \leq 0) \implica \neg B \)
\end{itemize}

\textbf{Primer paso} Probamos la primera implicación:

\{ I \land B \land F_v = v_0\} S \{ F_v < v_0 \}

\[
\{0 \leq i \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res \land 0 \leq i \leq |\text{ciudades}| \land F_v = |\text{ciudades}| - i - 1\} \implica 
\]

\[
wp(S, F_v < v_0) 
\]


Calculamos la wp para probar \{ I \land B \land F_v = v_0\} \implica wp(S, \{ F_v < v_0 \}) 

\[
wp(S1, wp(S2, F_v < v_0)) \equiv 
\]

\[
wp(S1, wp(i:=i+1, |\text{ciudades}|- i - 1 < v_0)) \equiv
\]

\[
	def(i := i + 1) \land |ciudades| - (i + 1) - 1 < v_0 \equiv
\]

\[
wp(S1, True \land |\text{ciudades}| - i - 2 < v_0) \equiv
\]

\[
wp(res:= res + \text{ciudades}[i].habitantes, |\text{ciudades}| - i - 2 < v_0) = 
\]

\[
def(res := res + ciudades[i].habitantes) \yLuego |ciudades| - i - 2 < v_0 \equiv
\]

\[
wp(S, F_v < v_0) \equiv 0 \leq i < |ciudades| \yLuego |ciudades| - i - 2 < v_0
\]

Finalmente la implicación nos queda de la forma

\{ I \land B \land F_v = v_0\} \implica wp(S, F_v < v_0)

\[
\{0 \leq i \leq |\text{ciudades}| \yLuego \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes = res \land 0 \leq i < |\text{ciudades}| \land |\text{ciudades}| - i - 1\ = v_0} \implica 
\]

\[
0 \leq i < |ciudades| \yLuego |ciudades| - i - 2 < v_0 \equiv
\]

\[
	|ciudades| - i - 2 < |ciudades| - i - 1 \equiv True
\]

\textbf{Segundo paso} Probamos la segunda implicación:

(I \land F_v \leq 0) \implica \neg B

\[
0 \leq i \leq |\text{ciudades}| \yLuego res = \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes \yLuego |\text{ciudades}| - i - 1 \leq 0 \implica i \geq |\text{ciudades}| \equiv
\]

\[
0 \leq i \leq |\text{ciudades}| \yLuego |\text{ciudades}| \leq i + 1 \implica i \geq |\text{ciudades}| \equiv
\]

\[
i = |\text{ciudades}| \implica i \geq |\text{ciudades}| \equiv
\]

\[
True
\]

\subsection{Ejercicio 2}

Teniendo en cuenta la correctitud del programa demostrada en el 2.1, sabemos que el valor devuelto por el programa, siempre que se cumpla la precondición, tendrá la pinta de:

% \[
% \existe[unalinea]{k}{\ent}{0 \leq k < |ciudades|} \land \paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades|}
% \]

\[
\text{res} = \sum_{j=0}^{|ciudades|-1} \text{ciudades}[j].habitantes 
\]

En el procedimiento, se especifica que el parámetro de entrada es de tipo IN, por lo tanto en la precondición y la postcondición, el parámetro \textit{ciudades} mantendrá las mismas características, entre ellas que sus elementos son todos mayores o iguales a 0. Por lo tanto, al tomar un elemento de \textit{ciudades}, obligatoriamente será menor o igual a la sumatoria del total de elementos de \textit{ciudades}, es decir:

\[
	\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades|} \implicaLuego
\]

\[
\textit{ciudades}[i].habitantes \leq \sum_{j=0}^{|ciudades|-1} \text{ciudades}[j].habitantes 
\]

Ahora bien, según la postcondición sabemos que res es igual la sumatoria de todos sus elementos, entre los cuales sabemos que al menos alguno de ellos es mayor a 50.000, por lo tanto:

\[
\existe[unalinea]{k}{\ent}{0 \leq k < |ciudades|} \yLuego
\]

\[
50.000 < \textit{ciudades}[k].habitantes  
\]

Podemos afirmar entonces que:

\[
50.000 < \textit{ciudades}[k].habitantes \leq \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes 
\]

Y por transitividad concluimos que:

\[
50.000 < \sum_{j=0}^{i-1} \text{ciudades}[j].habitantes
\]

\end{document}
